from .base import BaseTransformer


class PythonPydanticTransformer(BaseTransformer):
    LANG = 'python[pydantic]'
    TOP_COMMENT = \
        '"""\n' \
        '{classname} type definition file generated by TypeBuf\n' \
        'Note: Any changes made to this file will be overwritten\n' \
        '      during next compilation\n' \
        '"""\n\n'
    TYPE_TRANSLATIONS = {
        'any': 'Any',
        'string': 'str',
        'int': 'int',
        'float': 'float',
        'boolean': 'bool',
        'bytes': 'str',
        'date': 'Date',
        'datetime': 'Datetime',
        'map': 'Dict',
        'array': 'List',
        'tuple': 'Tuple',
        'null': 'None',
        'double': 'float',
        'sint8': 'int',
        'sint16': 'int',
        'sint32': 'int',
        'sint64': 'int',
        'uint8': 'int',
        'uint16': 'int',
        'uint32': 'int',
        'uint64': 'int',
    }
    WS = '    '
    OPTIONAL = 'Optional[{type}]'
    FILENAME = '{classnamelower}.py'
    CLASS_DEF = 'class {classname}(BaseModel):\n'
    CLASS_ATTR_WITH_T = '{ws}{attrname}: {typeannotation}\n'

    def __init__(self, typedef: 'typebuf.models.typedefinition.TypeDefinition'):
        self.C = self.__class__
        self.typedef = typedef
        self.output_file: str = ''
        self.output_buf: str = ''
        self.method_order = [
            self.generate_top_comment,
            self.generate_imports,
            self.generate_class_declaration,
            self.generate_attributes
        ]

    def generate_filename(self):
        self.output_file = self.C.FILENAME.format(
            classnamelower=self.typedef.typename.lower()
        )

    def generate_imports(self) -> str:
        """
        Will scan the typedef for any imports we might need to do and return the import str
        :param typedef:
        :return: (str) The actual import str to write to the file or just "\n" if none
        """

        # This block will add the standard pydantic import if it wasn't specified
        if not self.typedef.imports:
            self.typedef.imports = {}
        if not self.typedef.imports.get(self.C.LANG):
            self.typedef.imports[self.C.LANG] = []

        if self.C.LANG in self.typedef.imports:
            if 'from pydantic import BaseModel' not in self.typedef.imports[self.C.LANG]:
                self.typedef.imports[self.C.LANG].append('from pydantic import BaseModel')
            return '\n'.join(self.typedef.imports[self.C.LANG]) + '\n\n'

        return '\n\n'

    def generate_top_comment(self) -> str:
        return self.C.TOP_COMMENT.format(
            classname=self.typedef.typename.capitalize()
        )

    def generate_class_declaration(self) -> str:
        return self.C.CLASS_DEF.format(classname=self.typedef.typename)

    def generate_type_annotation(self, attribute_type) -> str:
        if attribute_type.startswith('$'):
            return attribute_type[1:]
        if '|' in attribute_type:
            attribute_types = [a.strip() for a in attribute_type.split('|')]
            attribute_types = [self.C.TYPE_TRANSLATIONS[a] for a in attribute_types]
            return f'Union[{", ".join(attribute_types)}]'
        return self.C.TYPE_TRANSLATIONS[attribute_type]

    def generate_attributes(self) -> str:
        output_str = ''

        for attribute in self.typedef.fields:
            attrname = attribute.name
            typeannotation = self.generate_type_annotation(attribute.type)
            if attribute.optional:
                typeannotation = self.C.OPTIONAL.format(type=typeannotation)
            output_str += self.C.CLASS_ATTR_WITH_T.format(
                ws=self.C.WS, attrname=attrname,
                typeannotation=typeannotation
            )

        return output_str
