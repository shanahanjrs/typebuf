from .base import BaseTransformer


class TypeScriptTransformer(BaseTransformer):
    LANG = 'typescript'
    TOP_COMMENT = \
        '/**\n' \
        ' * {classname} type definition file generated by TypeBuf\n' \
        ' * Note: Any changes made to this file will be overwritten\n' \
        ' *       during next compilation\n' \
        ' */\n\n'
    TYPE_TRANSLATIONS = {
        'any': 'Any',
        'string': 'string',
        'int': 'number',
        'float': 'number',
        'boolean': 'boolean',
        'bytes': 'str',
        'date': 'Date',
        'datetime': 'Date',
        'map': 'Map',
        'array': 'Array',
        'tuple': '[{}, {}]',
        'null': 'null',
        'double': 'number',
        'sint8': 'number',
        'sint16': 'number',
        'sint32': 'number',
        'sint64': 'number',
        'uint8': 'number',
        'uint16': 'number',
        'uint32': 'number',
        'uint64': 'number',
    }
    WS = '  '
    OPTIONAL = '?'
    FILENAME = '{classnamelower}.ts'
    CLASS_DEF = 'interface {classname} {{\n{attributeblock}}}'
    CLASS_ATTR_WITH_T = '{ws}{attrname}{optional}: {typeannotation};\n'

    def __init__(self, typedef: 'typebuf.lib.TypeDefinition'):
        self.C = self.__class__
        self.typedef = typedef
        self.output_file: str = ''
        self.output_buf: str = ''
        self.method_order = [
            self.generate_top_comment,
            self.generate_imports,
            self.generate_class_declaration,
        ]

    def generate_filename(self):
        self.output_file = self.C.FILENAME.format(
            classnamelower=self.typedef.typename.lower()
        )

    def generate_imports(self) -> str:
        # Figure out a good way to do this
        # Cheat for now
        """
        Will scan the typedef for any imports we might need to do and return the import str
        :param typedef:
        :return: (str) The actual import str to write to the file or just "\n" if none
        """
        if not self.typedef.imports:
            return ''
        if self.C.LANG in self.typedef.imports:
            return '\n'.join(self.typedef.imports[self.C.LANG]) + '\n\n'

    def generate_top_comment(self):
        return self.C.TOP_COMMENT.format(
            classname=self.typedef.typename.capitalize()
        )

    def generate_class_declaration(self):
        return self.C.CLASS_DEF.format(
            classname=self.typedef.typename, attributeblock=self.generate_attributes()
        )

    def generate_type_annotation(self, attribute_type):
        if attribute_type.startswith('$'):
            return attribute_type[1:]
        return self.C.TYPE_TRANSLATIONS[attribute_type]

    def generate_attributes(self) -> str:
        output_str = ''
        for attribute in self.typedef.fields:
            ws = self.C.WS
            optional = self.C.OPTIONAL if attribute.optional else ''
            attrname = attribute.name
            typeannotation = self.generate_type_annotation(attribute.type)
            output_str += self.C.CLASS_ATTR_WITH_T.format(
                ws=ws, attrname=attrname, optional=optional,
                typeannotation=typeannotation
            )
        return output_str
